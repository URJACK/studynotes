# Numpy

## Menu

[TOC]

## 摘要

```python
def main():
    my_arr = np.arange(1000000)
    my_list = list(range(1000000))
    t0 = time.time()
    for _ in range(10):
        my_arr2 = my_arr * 2
    t1 = time.time()
    print(t1 - t0)
    t2 = time.time()
    for _ in range(10):
        my_list = [x * 2 for x in my_list]
    t3 = time.time()
    print(t3 - t2)
```

---

```
0.017008543014526367
0.6392581462860107
```

我们发现使用numpy对大量数据运算具有比python原生列表类型的运算相比，具有35倍的算力优势（在该例中）。

“基于NumPy的算法要比纯Python快10到100倍（甚至更快），并且使用的内存更少。”，这是官方声称。

## 基础使用

### 数组对象的创建

arr.ndim 可以查看数组的维度

arr.shape 可以查看数组的具体形状

#### array函数创建对象

传入一个普通的python列表

```python
def main():
    data1 = [6, 7.5, 8, 0, 1]
    arr1 = np.array(data1)
    print(arr1)
```

---

```
[6.  7.5 8.  0.  1. ]
```

传入嵌套的python列表

```python
def main():
    data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
    arr2 = np.array(data2)
    print(arr2)
    print(arr2.ndim)
    print(arr2.shape)
```

---

```
[[1 2 3 4]
 [5 6 7 8]]
2
(2, 4)
```

#### 全0，全1，没有具体值的数组

```python
def main():
    print(np.zeros(10))
    print(np.zeros((3, 6)))
    print(np.empty((2, 3, 2)))
    print(np.arange(15))
```

---

```
[0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]
[[0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0.]
 [0. 0. 0. 0. 0. 0.]]
[[[6.23042070e-307 4.22795269e-307]
  [7.56602523e-307 1.42417221e-306]
  [7.56595733e-307 1.60216183e-306]]

 [[8.45596650e-307 8.90092016e-307]
  [6.23058368e-307 6.89812960e-307]
  [1.00136387e-307 1.02359645e-306]]]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14]
```

#### 依序创建数组

```python
def main():
    data = np.arange(32).reshape(4, 8)
    print(data)
```

---

```
[[ 0  1  2  3  4  5  6  7]
 [ 8  9 10 11 12 13 14 15]
 [16 17 18 19 20 21 22 23]
 [24 25 26 27 28 29 30 31]]
```

#### 数据类型

```python
def main():
    arr1 = np.array([1, 2, 3], dtype=np.float64)
    arr2 = np.array([1, 2, 3], dtype=np.int32)

    print(arr1.dtype)
    print(arr2.dtype)
```

---

```
float64
int32
```

##### numpy数据类型包括

```
int8,uint8				i1\u1
int16,uint16			i2\u2
int32,uint32			i4\u4
int64,uint64			i8\u8

float16					f2
float32					f4(f)
float64					f8(d)
float128				f16(g)

complex64,complex128	c8\c16
complex256				c32
bool					?

object					O
string_					S
unicode_				U
```

##### 切换数据类型

```python
def main():
    arr = np.array([1, 2, 3, 4, 5])
    print(arr.dtype)

    float_arr = arr.astype(np.float64)
    print(float_arr.dtype)
```

---

```
int32
float64
```

浮点切换到整型的时候

```python
def main():
    arr = np.array([3.7, -1.2, -2.6, 0.5, 12.9, 10.1])
    print(arr)
    print(arr.astype(np.int32))
```

---

```
[ 3.7 -1.2 -2.6  0.5 12.9 10.1]
[ 3 -1 -2  0 12 10]
```

字符串型转浮点型

```python
def main():
    numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
    print(numeric_strings.astype(float))
```

---

```
[ 1.25 -9.6  42.  ]
```

使用简写指定数据类型

```python
def main():
    empty_uint32 = np.empty(8, dtype='u4')
    print(empty_uint32)
    print(empty_uint32.dtype)
```

---

```
[4128860 6029375 3801156 7536732 6684783 7798900 7471201 7536741]
uint32
```

### 数组对象的运算

#### 基础运算

```python
def main():
    arr = np.array([[1., 2., 3.], [4., 5., 6.]])
    print(arr)
    print(arr * arr)
    print(arr - arr)
```

---

```
[[1. 2. 3.]
 [4. 5. 6.]]
[[ 1.  4.  9.]
 [16. 25. 36.]]
[[0. 0. 0.]
 [0. 0. 0.]]
 [[1.         0.5        0.33333333]
 [0.25       0.2        0.16666667]]
[[1.         1.41421356 1.73205081]
 [2.         2.23606798 2.44948974]]
```

#### 比较运算

```python
def main():
    arr = np.array([[1., 2., 3.], [4., 5., 6.]])
    arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

    print(arr2)
    print(arr2 > arr)
```

---

```
[[ 0.  4.  1.]
 [ 7.  2. 12.]]
[[False  True False]
 [ True False  True]]
```

#### 数组的广播

两个数组维度不同的时候，对应元素的操作便成为了不可能。

numpy中，为了让这种操作成为可能，诞生了**广播**概念，**较小的数组扩展到较大数组的大小**，从而让形状可以兼容。

```python
def main():
    a = np.array([[0.0, 0.0, 0.0], [10.0, 10.0, 10.0], [20.0, 20.0, 20.0], [30.0, 30.0, 30.0]])
    b = np.array([1.0, 2.0, 3.0]) # np.array([[1.0, 2.0, 3.0], [2.0, 4.0, 6.0]]) 会无法广播，必须要求维度长度为1
    print('\n第一个数组加第二个数组：')
    print(a + b)
```

---

```
第一个数组加第二个数组：
[[ 1.  2.  3.]
 [11. 12. 13.]
 [21. 22. 23.]
 [31. 32. 33.]]
```

![image-20200815161138062](.\numpy\image-20200815161138062.png)

#### 数组的切片

数组和数组的切片**都是ndarray类型**，

数组的切片返回的是数据的引用，**对切片进行修改**，会直接对引用的内容进行修改，也即**会对原数组中的内容进行修改**

```python
def main():
    arr = np.arange(10)
    print(type(arr))
    # arr的第6个元素
    print(arr[5])
    # arr的第6-8个元素，[5:8]左闭右开
    print(arr[5:8])
    print(type(arr[5:8]))

    arr[5:8] = 12
    print(arr)

    arrslice = arr[5:8]
    # arrslice = arr[5:8].copy() 使用copy，可以让获取到完整的拷贝内容
    print(arrslice)
    arrslice[1] = 12345
    print(arr)
```

---

```
<class 'numpy.ndarray'>
5
[5 6 7]
<class 'numpy.ndarray'>
[ 0  1  2  3  4 12 12 12  8  9]
[12 12 12]
[    0     1     2     3     4    12 12345    12     8     9]
```

高维数组的切片

```python
def main():
    arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    print(arr2d[:2])
    print('===========分割线============')
    print(arr2d[:2, 1:])
```

---

```
[[1 2 3]
 [4 5 6]]
===========分割线============
[[2 3]
 [5 6]]
```

![image-20200815171113551](.\numpy\image-20200815171113551.png)

#### 数组的访问

高维数组，会访问旗下所有的低维度数组

numpy访问低维度数组的时候，可以使用**传统编程语言中的方式**，也可以**使用逗号隔开**。

```python
def main():
    arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
    print(arr2d[2])    
    print(arr2d[0][2])
    print(arr2d[0, 2])
```

---

```
[7 8 9]
3
3
```

以三维数组为例

```python
def main():
    arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
    print(arr3d)
    print('===========分割线============')
    # 将arr3d[0]的数据进行备份
    old_values = arr3d[0].copy()
    # 修改arr3d[0]的值为42
    arr3d[0] = 42
    print(arr3d)
    print('===========分割线============')
    arr3d[0] = old_values
    print(arr3d)
```

---

```
[[[ 1  2  3]
  [ 4  5  6]]

 [[ 7  8  9]
  [10 11 12]]]
===========分割线============
[[[42 42 42]
  [42 42 42]]

 [[ 7  8  9]
  [10 11 12]]]
===========分割线============
[[[ 1  2  3]
  [ 4  5  6]]

 [[ 7  8  9]
  [10 11 12]]]
```

#### 布尔型数组作为mask

注意这里的布尔型数组是可以用于索引的

```python
def main():
    names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
    data = np.random.randn(7, 4)
    data2 = np.random.randn(4, 7)

    print(names)
    print(data)
    print("===========分割线============")
    print(data2)
    print("===========分割线============")
    print(names == 'Bob')
    print("===========分割线============")
    print(data[names == 'Bob'])
    print("===========分割线============")
    print(data2[:, names == 'Bob'])
```

---

```
['Bob' 'Joe' 'Will' 'Bob' 'Will' 'Joe' 'Joe']
[[ 0.60859815 -0.90089578 -0.85112618  0.56020879]
 [ 0.82051232  0.56333562 -1.30749691 -0.80219104]
 [-1.67477705  1.18955912 -0.92636774  0.64393345]
 [ 1.32567685 -0.20140965 -0.3009827  -0.4195544 ]
 [-0.72658809  0.44310871 -0.69378433 -0.63055269]
 [-0.00845647 -0.34014677 -1.0335764   1.17213678]
 [ 0.30763311 -0.01404067  1.20807624 -1.38061016]]
===========分割线============
[[-0.039676    0.44269837  0.00334851  0.14265801 -0.83667387 -0.39251763
   1.97220194]
 [ 1.14358267  0.63409038 -0.27115216  0.35524143  0.70221966  0.33517664
  -0.55026191]
 [ 0.62417    -2.07490223  0.04930527  1.58178181 -1.20285059 -0.08696863
   1.22771086]
 [ 0.25145175 -0.03053961 -0.31460743  1.63036823  0.30890149  0.77917881
   0.80961653]]
===========分割线============
[ True False False  True False False False]
===========分割线============
[[ 0.60859815 -0.90089578 -0.85112618  0.56020879]
 [ 1.32567685 -0.20140965 -0.3009827  -0.4195544 ]]
===========分割线============
[[-0.039676    0.14265801]
 [ 1.14358267  0.35524143]
 [ 0.62417     1.58178181]
 [ 0.25145175  1.63036823]]
```

布尔索引选取数组会创建出**数组的副本**而不是**引用**

下面这个栗子可以看出，对选取数组做修改后，原数组并没有修改

```python
def main():
    names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
    data = np.random.randn(7, 4)

    mask = (names == 'Bob') | (names == 'Will')
    print(mask)
    dataselect = data[mask]
    print("================")
    print(dataselect)
    dataselect[0] = [2, 1, 4, 4]
    print("================")
    print(dataselect)
    print("================")
    print(data)
```

---

```
[ True False  True  True  True False False]
================
[[ 1.3547337  -0.66167581  0.08131174 -0.14937702]
 [-1.6330277   0.53577389  0.515607    1.57541763]
 [-1.79901459  0.08466193 -1.16408262 -1.51292612]
 [-0.79197905  0.64624225 -1.36432962  1.53912525]]
================
[[ 2.          1.          4.          4.        ]
 [-1.6330277   0.53577389  0.515607    1.57541763]
 [-1.79901459  0.08466193 -1.16408262 -1.51292612]
 [-0.79197905  0.64624225 -1.36432962  1.53912525]]
================
[[ 1.3547337  -0.66167581  0.08131174 -0.14937702]
 [ 0.86533632 -2.10944425 -1.33231878 -0.16303122]
 [-1.6330277   0.53577389  0.515607    1.57541763]
 [-1.79901459  0.08466193 -1.16408262 -1.51292612]
 [-0.79197905  0.64624225 -1.36432962  1.53912525]
 [ 0.62319918  0.45889506  1.35455111 -0.26864321]
 [ 0.29751441  1.05525918 -0.97927316  1.31214693]]
```

#### 整数数组作为索引

```python
def main():
    arr = np.empty((8, 4))
    for i in range(8):
        arr[i] = i
    print(arr)
    print("================")
    print(arr[[4, 3, 0, 6]])  # [4, 3, 0, 6] 作为索引
    print("================")
    print(arr[[-1, -3, -5, -7]])  # [-1, -3, -5, -7] 作为索引
```

---

```
[[0. 0. 0. 0.]
 [1. 1. 1. 1.]
 [2. 2. 2. 2.]
 [3. 3. 3. 3.]
 [4. 4. 4. 4.]
 [5. 5. 5. 5.]
 [6. 6. 6. 6.]
 [7. 7. 7. 7.]]
================
[[4. 4. 4. 4.]
 [3. 3. 3. 3.]
 [0. 0. 0. 0.]
 [6. 6. 6. 6.]]
================
[[7. 7. 7. 7.]
 [5. 5. 5. 5.]
 [3. 3. 3. 3.]
 [1. 1. 1. 1.]]
```

我们再来看一个栗子

```python
def main():
    arr = np.arange(32).reshape((8, 4))
    print(arr)
    print(arr[[1, 5, 7, 2], [0, 3, 1, 2]])  # 分别选取 arr[1][0]  arr[5][3]  arr[7][1]  arr[2][2]
```

---

```
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]
 [16 17 18 19]
 [20 21 22 23]
 [24 25 26 27]
 [28 29 30 31]]
[ 4 23 29 10]
```

#### 数组的转置

数组的转置返回的是**数组元素的引用**，而不是副本

```python
def main():
    arr = np.arange(15).reshape((3, 5))
    arr_t = arr.T
    print(arr)
    print(arr_t)
    arr_t[1][0] = 2
    print(arr)
```

---

```
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
[[ 0  5 10]
 [ 1  6 11]
 [ 2  7 12]
 [ 3  8 13]
 [ 4  9 14]]
[[ 0  2  2  3  4]
 [ 5  6  7  8  9]
 [10 11 12 13 14]]
```

高维数组的转置

```python
def main():
    arr = np.arange(16).reshape((2, 2, 4))
    print(arr)
    print('==========分割线==============')
    print(arr.transpose((1, 0, 2)))
```

---

```
[[[ 0  1  2  3]
  [ 4  5  6  7]]

 [[ 8  9 10 11]
  [12 13 14 15]]]
==========分割线==============
[[[ 0  1  2  3]
  [ 8  9 10 11]]

 [[ 4  5  6  7]
  [12 13 14 15]]]
```

如何理解这个转置呢？同时实验，已经得出 arr == arr.transpose((0,1,2))

所以这个arrT = arr.transpose((1,0,2))是将arr的头两个维度进行转置，进而有

```
arrT[i][j][k] == arr[j][i][k]
```

对应到图像化的思维来说，可以这样理解

![image-20200815200900215](.\numpy\image-20200815200900215.png)

## 进阶使用之函数

### 通用函数

#### 元素级数组函数

$$
函数sqrt(x) = \sqrt{x} \ \ 函数square(x)=x^2\\
函数exp(x) = e^x\\
函数log(x)=lnx \ \ 函数log10(x)=log_{10}x \ \ 函数log2(x)=log_{2}x \ \ 函数log1p(x)=log_{2}(1+x)
$$

函数**abs**(x)=|x|， **fabs**(x) 可用于计算浮点数的绝对值 
函数**sign**(x)={1,0,-1} 可以得知这个元素的正负性
函数**ceil**(x)= 大于等于该值的最小整数
函数**floor**(x)=小于等于该值的最大整数

反三角函数系列

**arccos**,**arccosh**,**arcsin**,**arcsinh**,**arctan**,**arctanh**

最后一个比较特殊的 **logical_not**。如果数值是0，则返回1，如果数值非0，那么返回0。

```python
def main():
    arr = np.arange(10)

    print(arr)
    print(np.sqrt(arr))
    print(np.exp(arr))
```

---

```
[0 1 2 3 4 5 6 7 8 9]
[0.         1.         1.41421356 1.73205081 2.         2.23606798
 2.44948974 2.64575131 2.82842712 3.        ]
[1.00000000e+00 2.71828183e+00 7.38905610e+00 2.00855369e+01
 5.45981500e+01 1.48413159e+02 4.03428793e+02 1.09663316e+03
 2.98095799e+03 8.10308393e+03]
```

#### 比较函数

$$
函数maximum(x,y)与函数minimum(x,y)分别代表取较大值与较小值
$$

```python
def main():
    x = np.random.randn(8)
    y = np.random.randn(8)

    print(x)
    print(y)
    print(np.maximum(x, y))
```

---

```
[-1.95628069  0.27554251 -1.56771015 -0.69426688  1.16637328 -2.01204916
  1.15063957  0.79702202]
[-0.16831569 -0.28972679  0.24276746  0.53791697 -0.20591752 -0.26127903
 -1.46363542  0.88859534]
[-0.16831569  0.27554251  0.24276746  0.53791697  1.16637328 -0.26127903
  1.15063957  0.88859534]
```

#### 取值函数

$$
modf(x) = x小数部分,x整数部分
$$

```python
def main():
    arr = np.random.randn(7) * 5
    print(arr)

    remainder, whole_part = np.modf(arr)
    print(remainder)  # 小数部分
    print(whole_part)  # 整数部分
```

---

```
[ 6.57786015 -0.76996835  5.45262193  4.26324436  8.15751832 -5.25641168
  5.89285157]
[ 0.57786015 -0.76996835  0.45262193  0.26324436  0.15751832 -0.25641168
  0.89285157]
[ 6. -0.  5.  4.  8. -5.  5.]
```

#### 通用函数双参数操作

```python
def main():
    arr = np.random.randn(7) * 5
    print(arr)
    print(np.sqrt(arr))
    print(np.sqrt(arr, arr))  # 直接操作赋值给指定数组，无需要赋值操作
    print(arr)
```

---

```
[ 4.07576562 -0.4706747  -4.54128718 -1.66608451 -1.10392685 -7.46585334
 -0.10163727]
[2.01885255        nan        nan        nan        nan        nan
        nan]
[2.01885255        nan        nan        nan        nan        nan
        nan]
[2.01885255        nan        nan        nan        nan        nan
        nan]
```

### 二元通用函数

$$
add(x,y) \ \ subtract(x,y) \ \ multiply(x,y) \ \ divide(x,y) \ \ floor_divide(x,y) \ \ mod(x,y) \\
power(x,y) = x^y
$$

copysign(x,y) 会将y的符号赋值给x

```python
def main():
    a = np.arange(15).reshape((3, 5))
    b = np.ones(15).reshape((3, 5))
    print(np.add(a, b))  # print(a + b)
    print(np.subtract(a, b))  # print(a - b)
    print(np.power(a, b))
```

---

```
[[ 1.  2.  3.  4.  5.]
 [ 6.  7.  8.  9. 10.]
 [11. 12. 13. 14. 15.]]
[[-1.  0.  1.  2.  3.]
 [ 4.  5.  6.  7.  8.]
 [ 9. 10. 11. 12. 13.]]
[[ 0.  1.  2.  3.  4.]
 [ 5.  6.  7.  8.  9.]
 [10. 11. 12. 13. 14.]]
```

## 进阶使用之数据处理

### 点阵图

```python
def main():
    points = np.arange(-5, 5, 0.01)  # 1000 equally spaced points
    xs, ys = np.meshgrid(points, points)
    print(xs)
    print(ys)
```

---

```
[[-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 ...
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]
 [-5.   -4.99 -4.98 ...  4.97  4.98  4.99]]
 
 [[-5.   -5.   -5.   ... -5.   -5.   -5.  ]
 [-4.99 -4.99 -4.99 ... -4.99 -4.99 -4.99]
 [-4.98 -4.98 -4.98 ... -4.98 -4.98 -4.98]
 ...
 [ 4.97  4.97  4.97 ...  4.97  4.97  4.97]
 [ 4.98  4.98  4.98 ...  4.98  4.98  4.98]
 [ 4.99  4.99  4.99 ...  4.99  4.99  4.99]]
```

ys[0] 与 xs[0] 刚好可以构成一组y值固定为-5，x从[-5, 5]的点集

```
对ys[i][j] 与 xs[i][j]来说，i的变化，只会引起ys的变化，不会引起xs的变化
同样j的变化只会引起xs的变化，而不会引起ys的变化
```

$$
z = \sqrt{x^2 + y^2}
$$

```
    z = np.sqrt(xs ** 2 + ys ** 2)
    print(z)
```

---

```
[[7.07106781 7.06400028 7.05693985 ... 7.04988652 7.05693985 7.06400028]
 [7.06400028 7.05692568 7.04985815 ... 7.04279774 7.04985815 7.05692568]
 [7.05693985 7.04985815 7.04278354 ... 7.03571603 7.04278354 7.04985815]
 ...
 [7.04988652 7.04279774 7.03571603 ... 7.0286414  7.03571603 7.04279774]
 [7.05693985 7.04985815 7.04278354 ... 7.03571603 7.04278354 7.04985815]
 [7.06400028 7.05692568 7.04985815 ... 7.04279774 7.04985815 7.05692568]]
```

我们将点集经过如上运算，可以得到运算结果，我们将运算结果使用matplot绘制出来

```
    plt.imshow(z, cmap=plt.cm.gray)
    plt.colorbar()
    plt.show()
```

---

![image-20200815213627257](.\numpy\image-20200815213627257.png)

### 条件逻辑

```python
def main():
    xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
    yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
    cond = np.array([True, False, True, True, False])
    print(np.where(cond, xarr, yarr))
```

---

```
[1.1 2.2 1.3 1.4 2.5]
```

一个比较容易想到的应用场景是

```python
def main():
    arr = np.random.randn(4, 4)
    print(arr)
    arr = np.where(arr < 0, 0, arr)
    print(arr)
```

---

```
[[-1.34982482 -1.71884184  0.5296153  -0.20257741]
 [ 0.10363789  1.19839141 -0.09892473  0.61487993]
 [ 0.04207385 -1.44644857  0.13509736 -1.79113311]
 [ 0.21099773  0.03534766 -1.84925993  1.3098356 ]]
[[0.         0.         0.5296153  0.        ]
 [0.10363789 1.19839141 0.         0.61487993]
 [0.04207385 0.         0.13509736 0.        ]
 [0.21099773 0.03534766 0.         1.3098356 ]]
```

### 统计函数

sum，mean，std，均属于聚合计算aggregation,也可以称作约简reduction。
$$
sum() \ mean() \ std() \ var() \ min() \ max() \ argmin() \ argmax()
$$
ndarray对象自身具有mean，sum等方法，numpy库自身也具有同名的方法。

```python
def main():
    arr = np.random.randn(5, 4)
    print(arr)
    print(arr.mean())
    print(np.mean(arr))
    print(arr.sum())
```

---

[[ 1.44961007  0.26702598 -0.29419064 -0.69220113]
 [-1.54019526 -2.53057949  1.24464018  0.58136142]
 [ 0.33159259  0.0252589   0.1454243  -1.28821538]
 [-1.64869645  1.44022484 -0.67194776  0.81236129]
 [-0.3130584   1.21972291  0.9665678  -0.52323206]]
-0.050926314931396134
-0.050926314931396134
-1.0185262986279227

统计函数都具有一个较为明显的特点，就是axis

#### axis

```python
def main():
    arr = np.random.randn(5, 4)
    print(arr)
    print("==========")
    print(arr.mean(axis=1))
    print("")
    print(arr.sum(axis=0))
```

---

```
[[-0.42832393 -0.85123988 -0.16427294 -0.33239042]
 [-0.29529124  1.56274508  0.41760818 -0.9091471 ]
 [-0.65110069  0.24729327  0.61089515 -0.06576199]
 [-0.19080962 -1.76627093  1.72624999 -0.05792791]
 [-0.14564751 -0.48795761 -1.89578356  0.12397673]]
==========
[-0.44405679  0.19397873  0.03533144 -0.07218962 -0.60135299]

[-1.71117299 -1.29543006  0.69469683 -1.24125069]
```

![image-20200816004123878](.\numpy\image-20200816004123878.png)

#### 累加累乘统计函数

$$
cumsum() \ \ cumprod()
$$

```python
def main():
    arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
    print(arr)
    print(arr.cumsum(axis=0))
    print(arr.cumprod(axis=1))
```

---

```
[[0 1 2]
 [3 4 5]
 [6 7 8]]
[[ 0  1  2]
 [ 3  5  7]
 [ 9 12 15]]
[[  0   0   0]
 [  3  12  60]
 [  6  42 336]]
```

#### 统计函数

```python
def main():
    arr = np.random.randn(100)
    print((arr > 0).sum())  # 正数的个数
    print((arr < 0).sum())  # 负数的个数
    print((arr == 0).sum())  # 0的个数
```

---

```
47
53
0
```

### 排序函数

#### sort

```python
def main():
    a = np.array([[3, 7], [9, 1]])
    print('我们的数组是：')
    print(a)
    print('\n')
    print('调用 sort() 函数：')
    print(np.sort(a))
    print('\n')
    print('沿轴 0 排序：')
    print(np.sort(a, axis=0))
    print('\n')
    # 在 sort 函数中排序字段
    dt = np.dtype([('name', 'S10'), ('age', int)]) # 这个S10 可能是字符串的长度是10
    a = np.array([("raju", 21), ("anil", 25), ("ravi", 17), ("amar", 27)], dtype=dt)
    print('我们的数组是：')
    print(a)
    print('\n')
    print('按 name 排序：')
    print(np.sort(a, order='name'))
```

---

```
我们的数组是：
[[3 7]
 [9 1]]


调用 sort() 函数：
[[3 7]
 [1 9]]


沿轴 0 排序：
[[3 1]
 [9 7]]


我们的数组是：
[(b'raju', 21) (b'anil', 25) (b'ravi', 17) (b'amar', 27)]


按 name 排序：
[(b'amar', 27) (b'anil', 25) (b'raju', 21) (b'ravi', 17)]
```

#### argsort

```python
def main():
    x = np.array([3, 1, 2])
    print('我们的数组是：')
    print(x)
    print('\n')
    print('对 x 调用 argsort() 函数：')
    y = np.argsort(x)
    print(y)
    print('\n')
    print('以排序后的顺序重构原数组：')
    print(x[y])
    print('\n')
    print('使用循环重构原数组：')
    for i in y:
        print(x[i])
```

---

```
我们的数组是：
[3 1 2]


对 x 调用 argsort() 函数：
[1 2 0]


以排序后的顺序重构原数组：
[1 2 3]


使用循环重构原数组：
1
2
3
```

![image-20200816104613051](.\numpy\image-20200816104613051.png)

## 进阶使用之线性代数

```python
def main():
    x = np.array([[1., 2., 3.], [4., 5., 6.]])
    y = np.array([[6., 23.], [-1, 7], [8, 9]])
    print(x)
    print(y)
    print(x.dot(y))
```

---

```
[[1. 2. 3.]
 [4. 5. 6.]]
[[ 6. 23.]
 [-1.  7.]
 [ 8.  9.]]
[[ 28.  64.]
 [ 67. 181.]]
```

线性代数在numpy中具有专门的库numpy.linalg，里面包括的常用库函数有：

```
diag：以一维数组的形式返回方阵对角线的元素； 还可以将一维数组转换为方阵（非对角线元素为0）

dot：矩阵乘法

trace：对角线元素之和

det：计算矩阵行列式

eig：计算方阵的本征值和本征向量

inv：计算方阵的逆

solve：解线性方程组Ax=B，其中A是一个方阵

lstsq：计算Ax=B的最小二乘解
```

## 进阶使用之伪随机数

```python
def main():
    samples = np.random.normal(size=(4, 4))
    print(samples)
```

---

```
[[-0.46783536  1.02778739 -0.86414613  0.42146901]
 [ 0.0944722   0.11430514  0.31647604 -0.79669522]
 [ 0.27707301 -0.05497552 -0.3215208   0.3087969 ]
 [ 1.18240089 -0.27563298  1.16378812  0.2265365 ]]
```

因为伪随机数是依照种子来生成的，我们可以使用一个独立的种子环境，从而与其他的随机数的种子环境隔离开

```python
def main():
    rng = np.random.RandomState(1234) # 新的种子环境rng
    print(rng.randn(10))
```

---

```
[ 0.47143516 -1.19097569  1.43270697 -0.3126519  -0.72058873  0.88716294
  0.85958841 -0.6365235   0.01569637 -2.24268495]
```

numpy.random的常用函数包括：

seed：设置随机数种子

rand：产生均匀分布的样本值

randint：从给定的上下限范围随机选取整数

randn：产生正态分布（平均值0，标准差1）的样本值



binomial：产生二项分布的样本值

normal：产生正态（高斯）分布的样本值

beta：产生beta分布的样本值

chisquare：产生卡方分布的样本值

gamma：产生gamma分布的样本值

uniform：产生在[0,1]中均匀分布的样本值



permutation：返回一个序列的随机排列或者返回一个随机排列的范围

shuffle：对一个序列进行随机排列

### 使用python自带的随机方式

```python
def main():
    position = 0
    walk = [position]
    steps = 1000
    for i in range(steps):
        step = 1 if random.randint(0, 1) else -1
        position += step
        walk.append(position)
    print(walk)
    plt.plot(walk[:100])
    plt.show()
```

---

![image-20200816134408403](.\numpy\image-20200816134408403.png)

当然，我们可以利用前面学到的知识实现同样的的效果

```python
def main():
    position = 0
    walk = np.random.randint(0, 2, (1, 100), dtype=np.int8)  # 生成 [0,2) 的整数 右边是开区间
    walk = np.where(walk == 0, -1, walk)                     # 零替换成 -1
    print(walk)
    walk = np.cumsum(walk)                                   # 累加求和计步数
    plt.plot(walk[:100])
    plt.show()
```

