# 地下城游戏(leetcode174)

## 题目

一些恶魔抓住了公主（**P**）并将她关在了地下城的右下角。地下城是由 **M x N** 个房间组成的二维网格。我们英勇的骑士（**K**）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

**编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。**

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

| -2(K) | -3   | 3         |
| ----- | ---- | --------- |
| -5    | -10  | 1         |
| 10    | 30   | **-5(P)** |

## 思路

使用传统的BFS搜索基础上需要一些额外的操作。

原因很简单，如该图为例

```
以 -2 -> -3 -> 3 -> 1 -> -5  这条线路为例，最终到达终点的时候，求和为-6
但是我们知道，实际上  -2 -> -3 -> -3 -> 7 -> -5 最终求和结果-6，但实际上我们知道，它至少需要9点HP才能跑完这条路。
这说明了，在本题中，如果只通过最后的方格的求最大和来确定答案，是行不通的。

并且这衍生出一个问题，就是单元格应该记录什么信息？是最大和？还是最小差值？
最大和可能会给后序的计算提供更小的差值，但是也可能因此漏掉一些潜在提供最小差值的选择。
```

若按照以往的类似于背包问题中的dp定义，本题将会非常难解出。

### 题解

但本题如果这样定义、从（右下到左上）这个方向来，问题就将迎刃而解了。

```
dp[i][j] 代表：(i,j)点开始，营救公主，最低需要多少血量

dp[i][j] = Math.min( dp[i+1][j],dp[i][j+1] ) - dungeon[i][j] ?
当dungeon[i][j] < 0，需要扣除玩家血量的时候，dp[i][j]会变成正数，最低需要多少血量便可以得出了。非常的巧妙。
但当 dungeon[i][j] > 0，的时候，发现是给玩家回血的，整体作差可能会为负值，但玩家最少需要的血量并不可以为负值，此时需要将
dp[i][j]的数值设置为1。
全局来看dp[i][j] = Math.max(Math.min( dp[i+1][j],dp[i][j+1] ) - dungeon[i][j] , 1)
```

## Code

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        if (dungeon == null) {
            return 0;
        }
        int N = dungeon.length;
        if (dungeon.length == 0) {
            return 0;
        }
        int M = dungeon[0].length;
        int[][] dp = new int[N + 5][M + 5];
        for (int i = 0; i <= N; ++i) {
            Arrays.fill(dp[i], Integer.MAX_VALUE);
        }
        dp[N][M - 1] = 1;
        dp[N - 1][M] = 1;
        for (int i = N - 1; i >= 0; i--) {
            for (int j = M - 1; j >= 0; j--) {
                int temp = Math.min(dp[i + 1][j], dp[i][j + 1]);
                dp[i][j] = Math.max(temp - dungeon[i][j], 1);
            }
        }
        return dp[0][0];
    }
}
```

